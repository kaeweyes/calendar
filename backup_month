import React, { useEffect, useState, useMemo } from "react";

const API_BASE = "http://localhost:4000";

async function fetchEvents() {
  const res = await fetch(`${API_BASE}/events`);
  if (!res.ok) throw new Error("Failed to fetch events");
  return res.json();
}
async function createSeriesOnServer(series) {
  const res = await fetch(`${API_BASE}/events`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(series),
  });
  if (!res.ok) throw new Error("Failed to create series");
  return res.json();
}
async function deleteSeriesOnServer(id) {
  const res = await fetch(`${API_BASE}/events/${encodeURIComponent(id)}`, { method: "DELETE" });
  if (!res.ok) throw new Error("Failed to delete");
  return res.json();
}
async function addExclusionOnServer(id, date) {
  const res = await fetch(`${API_BASE}/events/${encodeURIComponent(id)}/exclude`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ date }),
  });
  if (!res.ok) throw new Error("Failed to exclude");
  return res.json();
}
async function setEndDateOnServer(id, endDate) {
  const res = await fetch(`${API_BASE}/events/${encodeURIComponent(id)}/end`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ endDate }),
  });
  if (!res.ok) throw new Error("Failed to set end date");
  return res.json();
}

const toISODate = (d) => new Date(d).toISOString().slice(0, 10);
const parseISODate = (s) => {
  const [y, m, dd] = s.split("-").map((n) => parseInt(n, 10));
  return new Date(y, m - 1, dd);
};
const addDays = (d, n) => {
  const nd = new Date(d);
  nd.setDate(nd.getDate() + n);
  return nd;
};
const weekdayIndex = (date) => date.getDay(); // 0 Sun .. 6 Sat
const weekOfMonth = (date) => Math.floor((date.getDate() - 1) / 7) + 1;

function occurrencesForSeriesInRange(series, monthStart, monthEnd) {
  const results = [];
  const start = parseISODate(series.startDate);
  // normalize repeat into array of strings
  const repeats = Array.isArray(series.repeat) ? series.repeat : [series.repeat || "none"];
  const ex = new Set(series.exclusions || []);
  const endDate = series.endDate ? parseISODate(series.endDate) : null;
  if (start > monthEnd && repeats.length === 1 && repeats[0] === "none") return results;

  for (let d = new Date(monthStart); d <= monthEnd; d.setDate(d.getDate() + 1)) {
    const ds = toISODate(d);
    if (endDate && d > endDate) break;
    if (d < start && repeats.length === 1 && repeats[0] === "none") continue;
    if (d < start && repeats.some(r => r !== "none" && r !== "yearly") && repeats.indexOf("yearly") === -1 && repeats.indexOf("none") === -1) {
      // if all repeats require d >= start we still keep checking per-rule below, so we can skip this complicated check
    }

    let match = false;

    // check each selected repeat rule — if any matches, this date is an occurrence
    for (const repeat of repeats) {
      if (repeat === "none") {
        if (ds === series.startDate) match = true;
      } else if (repeat === "daily") {
        if (d >= start) match = true;
      } else if (repeat === "weekly") {
        if (d >= start && weekdayIndex(d) === weekdayIndex(start)) match = true;
      } else if (repeat === "monthly") {
        if (d >= start && d.getDate() === start.getDate()) match = true;
      } else if (repeat === "yearly") {
        if (d >= start && d.getDate() === start.getDate() && d.getMonth() === start.getMonth()) match = true;
      } else if (repeat.startsWith("week")) {
        const weekN = parseInt(repeat.replace("week", ""), 10);
        if (d >= start && weekdayIndex(d) === weekdayIndex(start) && weekOfMonth(d) === weekN) match = true;
      }

      if (match) break;
    }

    if (match && !ex.has(ds)) {
      results.push({
        date: ds,
        seriesId: series.id,
        name: series.name,
        startTime: series.startTime,
        endTime: series.endTime,
        repeat: series.repeat, // keep original value (array or string) for rendering
      });
    }
  }

  return results;
}


const styles = {
  app: { fontFamily: "system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial", padding: 12 },
  header: { display: "flex", alignItems: "center", justifyContent: "space-between", gap: 12 },
  navbar: { padding: 8 },
  navbarList: { display: "flex", gap: 6, listStyle: "none", padding: 0, margin: 0, flexWrap: "wrap" },
  monthButton: { padding: "6px 10px", borderRadius: 6, border: "1px solid #bbb", background: "#fff", cursor: "pointer" },
  activeMonthButton: { background: "#2563eb", color: "white", border: "1px solid #2563eb", fontWeight: 700, },
  createButton: { padding: "6px 10px", borderRadius: 6, border: "1px solid #444", background: "#f3f3f3", cursor: "pointer", marginLeft: 8 },
  table: { borderCollapse: "collapse", width: "100%" },
  th: { border: "1px solid #ddd", padding: 8, background: "#fafafa", textAlign: "center" },
  td: { border: "1px solid #ccc", verticalAlign: "top", padding: 8, minWidth: 120, height: 80, position: "relative", cursor: "pointer" },
  today: { color: "crimson" },
  popupOverlay: { position: "fixed", inset: 0, display: "flex", alignItems: "center", justifyContent: "center", background: "rgba(0,0,0,0.45)", zIndex: 9999, padding: "1rem" },
  popupModal: { position: "relative", minWidth: 320, maxWidth: "92%", maxHeight: "92%", overflow: "auto", background: "white", borderRadius: 8, boxShadow: "0 10px 30px rgba(0,0,0,0.25)", padding: "1.25rem" },
  closeButton: { position: "absolute", right: 8, top: 8, border: "none", background: "transparent", fontSize: 20, lineHeight: 1, cursor: "pointer" },
  eventPreview: { borderRadius: 6, padding: "6px 8px", background: "#eef", display: "inline-block", maxWidth: "100%", whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" },
  formInput: { width: "100%", padding: "6px 8px", boxSizing: "border-box", marginTop: 6, marginBottom: 6 },
  smallBtn: { padding: "6px 8px", borderRadius: 6, border: "1px solid #aaa", cursor: "pointer" },
};


const Navbar = ({ selectedMonth, onMonthClick, onCreate }) => {
  const months = ["JAN", "FEB", "MAR", "APR", "MAY", "JUNE", "JUL", "AUG", "SEPT", "OCT", "NOV", "DEC"];

  return (
    <nav style={styles.navbar}>
      <ul style={styles.navbarList}>
        {months.map((m, i) => {
          const isActive = i === selectedMonth;

          return (
            <li key={m}>
              <button
                onClick={() => onMonthClick(i)}
                style={{
                  ...styles.monthButton,
                  ...(isActive ? styles.activeMonthButton : {}),
                }}
              >
                {m}
              </button>
            </li>
          );
        })}

        <li>
          <button style={styles.createButton} onClick={onCreate}>
            CREATE
          </button>
        </li>
      </ul>
    </nav>
  );
};

const Popup = ({ children, onClose, title }) => {
  useEffect(() => {
    const onKey = (e) => {
      if (e.key === "Escape") onClose?.();
    };
    document.addEventListener("keydown", onKey);
    const prevOverflow = document.body.style.overflow;
    document.body.style.overflow = "hidden";
    return () => {
      document.removeEventListener("keydown", onKey);
      document.body.style.overflow = prevOverflow;
    };
  }, [onClose]);

  return (
    <div style={styles.popupOverlay} onClick={onClose}>
      <div style={styles.popupModal} onClick={(e) => e.stopPropagation()}>
        <button aria-label="Close" onClick={onClose} style={styles.closeButton}>
          ✕
        </button>
        {title && <h3 style={{ marginTop: 0 }}>{title}</h3>}
        <div>{children}</div>
      </div>
    </div>
  );
};

const Table = ({ year, month, seriesArray, onServerRefresh }) => {
  const [openCell, setOpenCell] = useState(null);
  const [openCreateFromDay, setOpenCreateFromDay] = useState(null);
  const [fileError, setFileError] = useState(null);

  const weekdayNames = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];

  const occurrences = useMemo(() => {
    const monthStart = new Date(year, month, 1);
    const monthEnd = new Date(year, month + 1, 0);
    const map = {};
    for (const s of seriesArray) {
      try {
        const occs = occurrencesForSeriesInRange(s, monthStart, monthEnd);
        for (const o of occs) {
          map[o.date] = map[o.date] || [];
          map[o.date].push(o);
        }
      } catch (e) {
        console.error("occ gen error", e);
      }
    }
    Object.keys(map).forEach((k) =>
      map[k].sort((a, b) => (a.startTime || "") > (b.startTime || "") ? 1 : -1)
    );
    return map;
  }, [seriesArray, year, month]);

  const calendarGrid = useMemo(() => {
    const start = new Date(year, month, 1);
    const startOnMonday = new Date(start);
    const day = startOnMonday.getDay(); 
    const offset = day === 0 ? -6 : 1 - day; 
    startOnMonday.setDate(startOnMonday.getDate() + offset);

    const rows = [];
    let cur = new Date(startOnMonday);
    for (let w = 0; w < 6; w++) {
      const row = [];
      for (let wd = 0; wd < 7; wd++) {
        const inMonth = cur.getMonth() === month;
        const ds = toISODate(cur);
        row.push({
          date: new Date(cur),
          dateStr: ds,
          inMonth,
          occurrences: occurrences[ds] || [],
        });
        cur = addDays(cur, 1);
      }
      rows.push(row);
    }
    return rows;
  }, [month, year, occurrences]);

  async function refreshFromServer() {
    try {
      const arr = await fetchEvents();
      onServerRefresh(arr);
    } catch (err) {
      setFileError(err.message || String(err));
    }
  }

  async function handleDeleteOccurrence(seriesId, dateStr) {
    try {
      await addExclusionOnServer(seriesId, dateStr);
      await refreshFromServer();
      setOpenCell(null);
    } catch (err) {
      setFileError(err.message || String(err));
    }
  }

  async function handleRemoveSeriesFrom(seriesId, fromDateStr) {
    try {
      const fromDate = parseISODate(fromDateStr);
      const dayBefore = toISODate(addDays(fromDate, -1));
      await setEndDateOnServer(seriesId, dayBefore);
      await refreshFromServer();
      setOpenCell(null);
    } catch (err) {
      setFileError(err.message || String(err));
    }
  }

  async function handleDeleteSeries(seriesId) {
    try {
      await deleteSeriesOnServer(seriesId);
      await refreshFromServer();
      setOpenCell(null);
    } catch (err) {
      setFileError(err.message || String(err));
    }
  }

  return (
    <div>
      {fileError && <div style={{ color: "red" }}>File error: {fileError}</div>}
      <table style={styles.table}>
        <thead>
          <tr>
            {weekdayNames.map((d) => (
              <th key={d} style={styles.th}>
                {d}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {calendarGrid.map((row, rI) => (
            <tr key={rI}>
              {row.map((cell) => {
                const isToday = toISODate(new Date()) === cell.dateStr;
                const firstEvent = cell.occurrences && cell.occurrences.length ? cell.occurrences[0] : null;
                return (
                  <td
                    key={cell.dateStr}
                    onClick={() => setOpenCell(cell)}
                    style={{
                      ...styles.td,
                      background: cell.inMonth ? "#fff" : "#f8f8f8",
                    }}
                  >
                    <div style={{ position: "absolute", right: 6, top: 6, fontSize: 12, color: isToday ? "crimson" : "#666" }}>
                      {cell.date.getDate()}
                    </div>

                    <div style={{ marginTop: 18, fontSize: 13 }}>
                      {firstEvent ? (
                        <div style={styles.eventPreview}>
                          <div style={{ fontWeight: 600 }}>{firstEvent.name}</div>
                          <div style={{ fontSize: 12 }}>
                            {firstEvent.startTime || ""} {firstEvent.startTime && firstEvent.endTime ? "—" : ""} {firstEvent.endTime || ""}
                          </div>
                        </div>
                      ) : (
                        <div style={{ color: "#999", opacity: 0.8 }}>No events</div>
                      )}
                    </div>
                  </td>
                );
              })}
            </tr>
          ))}
        </tbody>
      </table>

      {openCell && (
        <Popup onClose={() => setOpenCell(null)} title={`Events — ${openCell.dateStr}`}>
          <div>
            {openCell.occurrences && openCell.occurrences.length > 0 ? (
              openCell.occurrences.map((o) => (
                <div key={`${o.seriesId}-${o.date}`} style={{ padding: 8, borderBottom: "1px solid #eee", display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                  <div>
                    <div style={{ fontWeight: 700 }}>{o.name}</div>
                    <div style={{ fontSize: 12 }}>
                      {o.startTime || ""} {o.endTime ? `— ${o.endTime}` : ""}{" "}
                      <span style={{ marginLeft: 8, fontStyle: "italic", color: "#666", fontSize: 12 }}>{o.repeat}</span>
                    </div>
                  </div>
                  <div style={{ display: "flex", gap: 8 }}>
                    <button style={styles.smallBtn} onClick={() => handleDeleteOccurrence(o.seriesId, o.date)}>
                      Remove
                    </button>
                    {o.repeat && o.repeat !== "none" && (
                      <button style={styles.smallBtn} onClick={() => handleRemoveSeriesFrom(o.seriesId, o.date)}>
                        Remove all future
                      </button>
                    )}
                    <button style={styles.smallBtn} onClick={() => handleDeleteSeries(o.seriesId)}>
                      Remove series
                    </button>
                  </div>
                </div>
              ))
            ) : (
              <div style={{ padding: 8, color: "#666" }}>No events on this day</div>
            )}

            <div style={{ marginTop: 12 }}>
              <button
                style={styles.smallBtn}
                onClick={() => {
                  setOpenCreateFromDay(openCell.dateStr);
                  setOpenCell(null);
                }}
              >
                Create event on this day
              </button>
              <button style={{ ...styles.smallBtn, marginLeft: 8 }} onClick={() => setOpenCell(null)}>
                Close
              </button>
            </div>
          </div>
        </Popup>
      )}

      {openCreateFromDay && (
        <CreateEventPopup
          defaultDate={openCreateFromDay}
          onClose={() => setOpenCreateFromDay(null)}
          onCreate={async (series) => {
            try {
              await createSeriesOnServer(series);
              const arr = await fetchEvents();
              onServerRefresh(arr);
              setOpenCreateFromDay(null);
            } catch (err) {
              setFileError(err.message || String(err));
            }
          }}
        />
      )}
    </div>
  );
};

const CreateEventPopup = ({ defaultDate, onClose, onCreate }) => {
  const [name, setName] = useState("");
  const [date, setDate] = useState(defaultDate || toISODate(new Date()));
  const [startTime, setStartTime] = useState("");
  const [endTime, setEndTime] = useState("");
  const [repeat, setRepeat] = useState([]);

  const repeatOptions = [
    { value: "none", label: "No repeats" },
    { value: "daily", label: "Every day" },
    { value: "weekly", label: "Weekly" },
    { value: "monthly", label: "Monthly" },
    { value: "yearly", label: "Yearly" },
    { value: "week1", label: "Week 1 of month (same weekday)" },
    { value: "week2", label: "Week 2 of month (same weekday)" },
    { value: "week3", label: "Week 3 of month (same weekday)" },
    { value: "week4", label: "Week 4 of month (same weekday)" },
  ];

  function toggleRepeat(val) {
    setRepeat(prev => {
      if (val === "none") return ["none"];
      const withoutNone = prev.filter(x => x !== "none");
      if (withoutNone.includes(val)) {
        return withoutNone.filter(x => x !== val);
      } else {
        return [...withoutNone, val];
      }
    });
  }

  function mkSeries() {
    return {
      id: `ts-${Date.now()}`,
      name: name || "Untitled",
      startDate: date,
      startTime: startTime || null,
      endTime: endTime || null,
      repeat: repeat.length ? repeat : ["none"], 
      exclusions: [],
      endDate: null,
      createdAt: new Date().toISOString(),
    };
  }

  return (
    <Popup onClose={onClose} title="Create event">
      <div style={{ display: "grid", gap: 8 }}>
        <label>
          Event name
          <input style={styles.formInput} value={name} onChange={(e) => setName(e.target.value)} placeholder="Event name" />
        </label>

        <label>
          Start date
          <input style={styles.formInput} type="date" value={date} onChange={(e) => setDate(e.target.value)} />
        </label>

        <label>
          Start time
          <input style={styles.formInput} type="time" value={startTime} onChange={(e) => setStartTime(e.target.value)} />
        </label>

        <label>
          End time
          <input style={styles.formInput} type="time" value={endTime} onChange={(e) => setEndTime(e.target.value)} />
        </label>

        <div>
          <div style={{ marginBottom: 6 }}>Repeats (pick one or more)</div>
          <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
            {repeatOptions.map(opt => (
              <label key={opt.value} style={{ fontSize: 14 }}>
                <input
                  type="checkbox"
                  checked={repeat.includes(opt.value)}
                  onChange={() => toggleRepeat(opt.value)}
                  style={{ marginRight: 8 }}
                />
                {opt.label}
              </label>
            ))}
          </div>
        </div>

        <div style={{ display: "flex", gap: 8, marginTop: 8 }}>
          <button
            style={styles.smallBtn}
            onClick={async () => {
              const series = mkSeries();
              await onCreate(series);
            }}
          >
            Create
          </button>
          <button style={styles.smallBtn} onClick={onClose}>
            Cancel
          </button>
        </div>
      </div>
    </Popup>
  );
};


export default function App() {
  const today = new Date();
  const [viewYear] = useState(today.getFullYear());
  const [viewMonth, setViewMonth] = useState(today.getMonth());
  const [seriesArray, setSeriesArray] = useState([]);
  const [showCreate, setShowCreate] = useState(false);
  const [fileErr, setFileErr] = useState(null);

  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const arr = await fetchEvents();
        if (mounted) setSeriesArray(arr);
      } catch (err) {
        setFileErr(err.message || String(err));
      }
    })();
    return () => {
      mounted = false;
    };
  }, []);

  async function handleMonthClick(monthIndex) {
    setViewMonth(monthIndex);
  }

  async function handleCreate(series) {
    try {
      await createSeriesOnServer(series);
      const arr = await fetchEvents();
      setSeriesArray(arr);
      setShowCreate(false);
    } catch (err) {
      setFileErr(err.message || String(err));
    }
  }

  async function handleServerRefresh(arr) {
    setSeriesArray(arr);
  }

  return (
    <div style={styles.app}>
      <div style={styles.header}>
        <h2 style={{ margin: 0 }}>My Local Calendar</h2>
        <div />
      </div>

      {/* <Navbar onMonthClick={handleMonthClick} onCreate={() => setShowCreate(true)} /> */}
      <Navbar selectedMonth={viewMonth} onMonthClick={handleMonthClick} onCreate={() => setShowCreate(true)}/>


      <div style={{ marginTop: 12 }}>
        <Table year={viewYear} month={viewMonth} seriesArray={seriesArray} onServerRefresh={handleServerRefresh} />
      </div>

      {showCreate && (
        <CreateEventPopup
          defaultDate={toISODate(new Date(viewYear, viewMonth, today.getDate()))}
          onClose={() => setShowCreate(false)}
          onCreate={async (series) => {
            await handleCreate(series);
          }}
        />
      )}

      {fileErr && <div style={{ color: "red", marginTop: 8 }}>{fileErr}</div>}

      <div style={{ marginTop: 12, color: "#666", fontSize: 13 }}>
        Events served from <code>{API_BASE}/events</code>
      </div>
    </div>
  );
}
